// src/utils.ts
<<<<<<< HEAD
function assert(condition, message) {
  if (!condition)
    throw new Error(message);
}
function isType(type, value) {
  return typeof value === type;
}
function isPromise(value) {
  return value instanceof Promise;
}
function define(obj, key, descriptor) {
  Object.defineProperty(obj, key, descriptor);
}
function defineValue(obj, key, value) {
  define(obj, key, { value, configurable: !0, writable: !0 });
}

// src/constants.ts
var SYMBOL_STATE = Symbol.for("tinyspy:spy");

// src/internal.ts
var spies = /* @__PURE__ */ new Set(), reset = (state) => {
  state.called = !1, state.callCount = 0, state.calls = [], state.results = [], state.resolves = [], state.next = [];
}, defineState = (spy2) => (define(spy2, SYMBOL_STATE, {
  value: { reset: () => reset(spy2[SYMBOL_STATE]) }
}), spy2[SYMBOL_STATE]), getInternalState = (spy2) => spy2[SYMBOL_STATE] || defineState(spy2);
function createInternalSpy(cb) {
  assert(
    isType("function", cb) || isType("undefined", cb),
    "cannot spy on a non-function value"
  );
  let fn = function(...args) {
    let state2 = getInternalState(fn);
    state2.called = !0, state2.callCount++, state2.calls.push(args);
    let next = state2.next.shift();
    if (next) {
      state2.results.push(next);
      let [type2, result2] = next;
      if (type2 === "ok")
        return result2;
      throw result2;
    }
    let result, type = "ok", resultIndex = state2.results.length;
    if (state2.impl)
      try {
        new.target ? result = Reflect.construct(state2.impl, args, new.target) : result = state2.impl.apply(this, args), type = "ok";
      } catch (err) {
        throw result = err, type = "error", state2.results.push([type, err]), err;
      }
    let resultTuple = [type, result];
    return isPromise(result) && result.then(
      (r) => state2.resolves[resultIndex] = ["ok", r],
      (e) => state2.resolves[resultIndex] = ["error", e]
    ), state2.results.push(resultTuple), result;
  };
  defineValue(fn, "_isMockFunction", !0), defineValue(fn, "length", cb ? cb.length : 0), defineValue(fn, "name", cb && cb.name || "spy");
  let state = getInternalState(fn);
  return state.reset(), state.impl = cb, fn;
}
function isMockFunction(obj) {
  return !!obj && obj._isMockFunction === !0;
}
function populateSpy(spy2) {
  let state = getInternalState(spy2);
  "returns" in spy2 || (define(spy2, "returns", {
    get: () => state.results.map(([, r]) => r)
  }), [
    "called",
    "callCount",
    "results",
    "resolves",
    "calls",
    "reset",
    "impl"
  ].forEach(
    (n) => define(spy2, n, { get: () => state[n], set: (v) => state[n] = v })
  ), defineValue(spy2, "nextError", (error) => (state.next.push(["error", error]), state)), defineValue(spy2, "nextResult", (result) => (state.next.push(["ok", result]), state)));
}

// src/spy.ts
function spy(cb) {
  let spy2 = createInternalSpy(cb);
  return populateSpy(spy2), spy2;
}

// src/spyOn.ts
var getDescriptor = (obj, method) => {
  let objDescriptor = Object.getOwnPropertyDescriptor(obj, method);
  if (objDescriptor)
    return [obj, objDescriptor];
  let currentProto = Object.getPrototypeOf(obj);
  for (; currentProto !== null; ) {
    let descriptor = Object.getOwnPropertyDescriptor(currentProto, method);
    if (descriptor)
      return [currentProto, descriptor];
    currentProto = Object.getPrototypeOf(currentProto);
  }
}, setPototype = (fn, val) => {
  val != null && typeof val == "function" && val.prototype != null && Object.setPrototypeOf(fn.prototype, val.prototype);
};
function internalSpyOn(obj, methodName, mock) {
  assert(
    !isType("undefined", obj),
    "spyOn could not find an object to spy upon"
  ), assert(
    isType("object", obj) || isType("function", obj),
    "cannot spyOn on a primitive value"
  );
  let [accessName, accessType] = (() => {
    if (!isType("object", methodName))
      return [methodName, "value"];
    if ("getter" in methodName && "setter" in methodName)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in methodName)
      return [methodName.getter, "get"];
    if ("setter" in methodName)
      return [methodName.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [originalDescriptorObject, originalDescriptor] = getDescriptor(obj, accessName) || [];
  assert(
    originalDescriptor || accessName in obj,
    `${String(accessName)} does not exist`
  );
  let ssr = !1;
  accessType === "value" && originalDescriptor && !originalDescriptor.value && originalDescriptor.get && (accessType = "get", ssr = !0, mock = originalDescriptor.get());
  let original;
  originalDescriptor ? original = originalDescriptor[accessType] : accessType !== "value" ? original = () => obj[accessName] : original = obj[accessName], original && isSpyFunction(original) && (original = original[SYMBOL_STATE].getOriginal());
  let reassign = (cb) => {
    let { value, ...desc } = originalDescriptor || {
      configurable: !0,
      writable: !0
    };
    accessType !== "value" && delete desc.writable, desc[accessType] = cb, define(obj, accessName, desc);
  }, restore = () => {
    originalDescriptorObject !== obj ? Reflect.deleteProperty(obj, accessName) : originalDescriptor && !original ? define(obj, accessName, originalDescriptor) : reassign(original);
  };
  mock || (mock = original);
  let spy2 = wrap(createInternalSpy(mock), mock);
  accessType === "value" && setPototype(spy2, original);
  let state = spy2[SYMBOL_STATE];
  return defineValue(state, "restore", restore), defineValue(state, "getOriginal", () => ssr ? original() : original), defineValue(state, "willCall", (newCb) => (state.impl = newCb, spy2)), reassign(
    ssr ? () => (setPototype(spy2, mock), spy2) : spy2
  ), spies.add(spy2), spy2;
}
var ignoreProperties = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function getAllProperties(original) {
  let properties = /* @__PURE__ */ new Set(), descriptors2 = {};
  for (; original && original !== Object.prototype && original !== Function.prototype; ) {
    let ownProperties = [
      ...Object.getOwnPropertyNames(original),
      ...Object.getOwnPropertySymbols(original)
    ];
    for (let prop of ownProperties)
      descriptors2[prop] || ignoreProperties.has(prop) || (properties.add(prop), descriptors2[prop] = Object.getOwnPropertyDescriptor(original, prop));
    original = Object.getPrototypeOf(original);
  }
  return {
    properties,
    descriptors: descriptors2
  };
}
function wrap(mock, original) {
  if (!original || // the original is already a spy, so it has all the properties
  SYMBOL_STATE in original)
    return mock;
  let { properties, descriptors: descriptors2 } = getAllProperties(original);
  for (let key of properties) {
    let descriptor = descriptors2[key];
    getDescriptor(mock, key) || define(mock, key, descriptor);
  }
  return mock;
}
function spyOn(obj, methodName, mock) {
  let spy2 = internalSpyOn(obj, methodName, mock);
  return populateSpy(spy2), ["restore", "getOriginal", "willCall"].forEach((method) => {
    defineValue(spy2, method, spy2[SYMBOL_STATE][method]);
  }), spy2;
}
function isSpyFunction(obj) {
  return isMockFunction(obj) && "getOriginal" in obj[SYMBOL_STATE];
}

// src/restoreAll.ts
function restoreAll() {
  for (let fn of spies)
    fn.restore();
  spies.clear();
}
export {
  createInternalSpy,
  getInternalState,
  internalSpyOn,
  restoreAll,
  spies,
  spy,
  spyOn
=======
function R(e, t) {
  if (!e)
    throw new Error(t);
}
function u(e, t) {
  return typeof t === e;
}
function b(e) {
  return e instanceof Promise;
}
function f(e, t, n) {
  Object.defineProperty(e, t, n);
}
function i(e, t, n) {
  Object.defineProperty(e, t, { value: n });
}

// src/constants.ts
var c = Symbol.for("tinyspy:spy");

// src/internal.ts
var g = /* @__PURE__ */ new Set(), C = (e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.next = [];
}, M = (e) => (f(e, c, { value: { reset: () => C(e[c]) } }), e[c]), A = (e) => e[c] || M(e);
function I(e) {
  R(u("function", e) || u("undefined", e), "cannot spy on a non-function value");
  let t = function(...s) {
    let r = A(t);
    r.called = !0, r.callCount++, r.calls.push(s);
    let m = r.next.shift();
    if (m) {
      r.results.push(m);
      let [l, o] = m;
      if (l === "ok")
        return o;
      throw o;
    }
    let p, d = "ok";
    if (r.impl)
      try {
        new.target ? p = Reflect.construct(r.impl, s, new.target) : p = r.impl.apply(this, s), d = "ok";
      } catch (l) {
        throw p = l, d = "error", r.results.push([d, l]), l;
      }
    let a = [d, p];
    if (b(p)) {
      let l = p.then((o) => a[1] = o).catch((o) => {
        throw a[0] = "error", a[1] = o, o;
      });
      Object.assign(l, p), p = l;
    }
    return r.results.push(a), p;
  };
  i(t, "_isMockFunction", !0), i(t, "length", e ? e.length : 0), i(t, "name", e && e.name || "spy");
  let n = A(t);
  return n.reset(), n.impl = e, t;
}
function v(e) {
  let t = A(e);
  f(e, "returns", {
    get: () => t.results.map(([, n]) => n)
  }), ["called", "callCount", "results", "calls", "reset", "impl"].forEach((n) => f(e, n, { get: () => t[n], set: (s) => t[n] = s })), i(e, "nextError", (n) => (t.next.push(["error", n]), t)), i(e, "nextResult", (n) => (t.next.push(["ok", n]), t));
}

// src/spy.ts
function z(e) {
  let t = I(e);
  return v(t), t;
}

// src/spyOn.ts
var k = (e, t) => Object.getOwnPropertyDescriptor(e, t), P = (e, t) => {
  t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
};
function E(e, t, n) {
  R(!u("undefined", e), "spyOn could not find an object to spy upon"), R(u("object", e) || u("function", e), "cannot spyOn on a primitive value");
  let [s, r] = (() => {
    if (!u("object", t))
      return [t, "value"];
    if ("getter" in t && "setter" in t)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t)
      return [t.getter, "get"];
    if ("setter" in t)
      return [t.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), m = k(e, s), p = Object.getPrototypeOf(e), d = p && k(p, s), a = m || d;
  R(a || s in e, `${String(s)} does not exist`);
  let l = !1;
  r === "value" && a && !a.value && a.get && (r = "get", l = !0, n = a.get());
  let o;
  a ? o = a[r] : r !== "value" ? o = () => e[s] : o = e[s], n || (n = o);
  let y = I(n);
  r === "value" && P(y, o);
  let O = (h) => {
    let { value: G, ...w } = a || {
      configurable: !0,
      writable: !0
    };
    r !== "value" && delete w.writable, w[r] = h, f(e, s, w);
  }, K = () => a ? f(e, s, a) : O(o), T = y[c];
  return i(T, "restore", K), i(T, "getOriginal", () => l ? o() : o), i(T, "willCall", (h) => (T.impl = h, y)), O(l ? () => (P(y, n), y) : y), g.add(y), y;
}
function W(e, t, n) {
  let s = E(e, t, n);
  return v(s), ["restore", "getOriginal", "willCall"].forEach((r) => {
    i(s, r, s[c][r]);
  }), s;
}

// src/restoreAll.ts
function Z() {
  for (let e of g)
    e.restore();
  g.clear();
}
export {
  I as createInternalSpy,
  A as getInternalState,
  E as internalSpyOn,
  Z as restoreAll,
  g as spies,
  z as spy,
  W as spyOn
>>>>>>> pr-7-snarf1974-CDN
};
